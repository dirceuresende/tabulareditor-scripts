{
  "Actions": [
    {
      "Name": "Formatting\\Apply FormatString for Currency (Selected Measures or Columns)",
      "Enabled": "true",
      "Execute": "\r\nforeach(var obj in Selected.Measures)\r\n{\r\n    obj.FormatString = \"$#,##0.00;-$#,##0.00\";\r\n}\r\n\r\n\r\nforeach(var obj in Selected.Columns)\r\n{\r\n        \r\n    if (obj.DataType == DataType.Double || obj.DataType == DataType.Decimal) \r\n    {\r\n        obj.FormatString = \"$#,##0.00;-$#,##0.00\";\r\n    }\r\n\r\n}\r\n\r\n",
      "Tooltip": "",
      "ValidContexts": "Measure, Column"
    },
    {
      "Name": "Formatting\\Apply Standard Format on All DateTime columns",
      "Enabled": "true",
      "Execute": "foreach(var column in Model.Tables.SelectMany(t => t.Columns)) {\r\n    \r\n    if(column.DataType == DataType.DateTime && column.FormatString != \"dd/MM/yyyy\")\r\n        column.FormatString = \"dd/MM/yyyy\";\r\n    \r\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "Formatting\\CamelCase to Proper Case",
      "Enabled": "true",
      "Execute": "foreach(var obj in Selected.OfType<ITabularNamedObject>()) {\r\n    var oldName = obj.Name;\r\n    var newName = new System.Text.StringBuilder();\r\n    for(int i = 0; i < oldName.Length; i++) {\r\n        // First letter should always be capitalized:\r\n        if(i == 0) newName.Append(Char.ToUpper(oldName[i]));\r\n\r\n        // A sequence of two uppercase letters followed by a lowercase letter should have a space inserted\r\n        // after the first letter:\r\n        else if(i + 2 < oldName.Length && char.IsLower(oldName[i + 2]) && char.IsUpper(oldName[i + 1]) && char.IsUpper(oldName[i]))\r\n        {\r\n            newName.Append(oldName[i]);\r\n            newName.Append(\" \");\r\n        }\r\n\r\n        // All other sequences of a lowercase letter followed by an uppercase letter, should have a space\r\n        // inserted after the first letter:\r\n        else if(i + 1 < oldName.Length && char.IsLower(oldName[i]) && char.IsUpper(oldName[i+1]))\r\n        {\r\n            newName.Append(oldName[i]);\r\n            newName.Append(\" \");\r\n        }\r\n        else\r\n        {\r\n            newName.Append(oldName[i]);\r\n        }\r\n    }\r\n    obj.Name = newName.ToString();\r\n}\r\n",
      "Tooltip": "",
      "ValidContexts": "Model, Table, TableObject, Relationship"
    },
    {
      "Name": "Formatting\\CamelCase to Proper Case (All Columns)",
      "Enabled": "true",
      "Execute": "foreach(var obj in Model.Tables.SelectMany(t => t.Columns)) {\r\n    var oldName = obj.Name;\r\n    var newName = new System.Text.StringBuilder();\r\n    for(int i = 0; i < oldName.Length; i++) {\r\n        // First letter should always be capitalized:\r\n        if(i == 0) newName.Append(Char.ToUpper(oldName[i]));\r\n\r\n        // A sequence of two uppercase letters followed by a lowercase letter should have a space inserted\r\n        // after the first letter:\r\n        else if(i + 2 < oldName.Length && char.IsLower(oldName[i + 2]) && char.IsUpper(oldName[i + 1]) && char.IsUpper(oldName[i]))\r\n        {\r\n            newName.Append(oldName[i]);\r\n            newName.Append(\" \");\r\n        }\r\n\r\n        // All other sequences of a lowercase letter followed by an uppercase letter, should have a space\r\n        // inserted after the first letter:\r\n        else if(i + 1 < oldName.Length && char.IsLower(oldName[i]) && char.IsUpper(oldName[i+1]))\r\n        {\r\n            newName.Append(oldName[i]);\r\n            newName.Append(\" \");\r\n        }\r\n        else\r\n        {\r\n            newName.Append(oldName[i]);\r\n        }\r\n    }\r\n    obj.Name = newName.ToString();\r\n}\r\n",
      "Tooltip": "",
      "ValidContexts": "Model, Relationship"
    },
    {
      "Name": "Formatting\\Clean Object Names",
      "Enabled": "true",
      "Execute": "#r \"System.Text.RegularExpressions\"\r\n\r\n/*\r\n * Title: Clean Object Names\r\n * \r\n * Author: Darren Gosbell, twitter.com/DarrenGosbell\r\n * \r\n * This script, when executed, will loop through your model and update the\r\n * names of any tables and columns with CamelCaseNames and insert spaces before upper\r\n * case characters so you end up with\r\n * \r\n * before: CalendarYearNum\r\n * after:  Calendar Year Num\r\n *\r\n * This script ignores any columns that already have spaces in the names \r\n * and any hidden columns. It also skips adjacent upper case characters\r\n * so \"MyTXTColumn\"  becomes \"My TXT Column\"\r\n */\r\n\r\n// this regular expression splits strings on underscores and changes from lower to upper case\r\n// so \"my_column_name\" becomes an array like {\"my\", \"_\", \"column\", \"_\", \"name\"}\r\n// and \"MyOtherColumnName\" becomes an array like {\"My\", \"Other\", \"Column\", \"Name\"}\r\nvar rex = new System.Text.RegularExpressions.Regex( \"(^[a-z]+|[A-Z]+(?![a-z])|[A-Z][a-z]+|[^A-Z,a-z]+|[_]|[a-z]+)\");\r\n\r\n// if any of the following are the first word of a table name they will be stripped out\r\nList<string> tablePrefixesToIgnore = new List<string>() {\"dim\",\"fact\", \"vw\",\"tbl\",\"vd\",\"td\",\"tf\",\"vf\"};\r\n\r\n// if any of the following ar ethe last word of a table name they will be stripped out\r\nList<string> tableSuffixesToIgnore = new List<string>() {\"dim\", \"fact\"};\r\n\r\nforeach (var tbl in Model.Tables) \r\n{\r\n    if (!tbl.IsHidden && !tbl.Name.Contains(\" \")) \r\n    {\r\n        string name = tbl.Name;\r\n        var matches = rex.Matches(name);\r\n        var firstWord = matches[0];\r\n        var lastWord = matches[matches.Count-1];\r\n        string[] words = matches\r\n                        .OfType<System.Text.RegularExpressions.Match>()\r\n                        .Where(m =>\r\n                                // skip words that are just underscores so that they are replaced with spaces\r\n                                m.Value != \"_\" \r\n                                // skip the first word if it matches one of the prefixes to ignore\r\n                                && !(m == firstWord && tablePrefixesToIgnore.Contains(m.Value,System.StringComparer.OrdinalIgnoreCase)) \r\n                                // skip the last word if it matches one of the suffixes to ignore\r\n                                && !(m == lastWord && tableSuffixesToIgnore.Contains(m.Value,System.StringComparer.OrdinalIgnoreCase )) \r\n                                )\r\n                        .Select(m => char.ToUpper(m.Value.First()) + m.Value.Substring(1))\r\n                        .ToArray();                \r\n        string result = string.Join(\" \", words);\r\n        tbl.Name = result;\r\n    }\r\n\r\n    foreach (var col in tbl.Columns)\r\n    {\r\n        if (!col.IsHidden && !col.Name.Contains(\" \")) \r\n        {\r\n            string name = col.Name;\r\n            string[] words = rex.Matches(name)\r\n                            .OfType<System.Text.RegularExpressions.Match>()\r\n                            // skip underscores \r\n                            .Where(m => m.Value != \"_\" )\r\n                            .Select(m => char.ToUpper(m.Value.First()) + m.Value.Substring(1))\r\n                            .ToArray();                \r\n            string result = string.Join(\" \", words);\r\n            col.Name = result;\r\n        }\r\n    }\r\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "Measures\\Create CountRows Measures",
      "Enabled": "true",
      "Execute": "/*\r\n * Title: Auto-generate COUNTROWS measures from tables\r\n * \r\n * Author: Edgar Walther, twitter.com/edgarwalther\r\n * \r\n * This script, when executed, will loop through the currently selected tables,\r\n * creating one COUNTROWS measure for each table.\r\n */\r\n \r\n // Loop through all currently selected tables:\r\nforeach(var table in Selected.Tables) {\r\n    \r\n    var newMeasure = table.AddMeasure(\r\n    \"# Rows in \" + table.Name,                         // Name\r\n    \"COUNTROWS(\" + table.DaxObjectFullName + \")\"       // DAX expression\r\n    );\r\n    \r\n    // Set the format string on the new measure:\r\n    newMeasure.FormatString = \"0\";\r\n\r\n    // Provide some documentation:\r\n    newMeasure.Description = \"This measure is the number of rows in table \" + table.DaxObjectFullName;\r\n    \r\n}",
      "Tooltip": "",
      "ValidContexts": "Table"
    },
    {
      "Name": "Measures\\Create DumpFilters Measure",
      "Enabled": "true",
      "Execute": "var dax = \"VAR MaxFilters = 3 RETURN \";\r\nvar dumpFilterDax = @\"IF (\r\n    ISFILTERED ( {0} ), \r\n    VAR ___f = FILTERS ( {0} )\r\n    VAR ___r = COUNTROWS ( ___f )\r\n    VAR ___t = TOPN ( MaxFilters, ___f, {0} )\r\n    VAR ___d = CONCATENATEX ( ___t, {0}, \"\", \"\" )\r\n    VAR ___x = \"\"{0} = \"\" & ___d \r\n        & IF(___r > MaxFilters, \"\", ... [\"\" & ___r & \"\" items selected]\"\") & \"\" \"\"\r\n    RETURN ___x & UNICHAR(13) & UNICHAR(10)\r\n)\";\r\n\r\n// Loop through all columns of the model to construct the complete DAX expression:\r\nbool first = true;\r\nforeach(var column in Model.AllColumns)\r\n{\r\n    if(!first) dax += \" & \";\r\n    dax += string.Format(dumpFilterDax, column.DaxObjectFullName);\r\n    if(first) first = false;\r\n}\r\n\r\n// Add the measure to the currently selected table:\r\nSelected.Table.AddMeasure(\"DumpFilters\", dax);",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "Measures\\Create Explicit Measures",
      "Enabled": "true",
      "Execute": "// Title: Auto-create explicit measures from all columns in all tables that have qualifying aggregation functions assigned \r\n//  \r\n// Author: Tom Martens, twitter.com/tommartens68\r\n// \r\n// This script, when executed, will loop through all the tables and creates explicit measure for all the columns with qualifying\r\n// aggregation functions.\r\n// The qualifiyng aggregation functions are SUM, COUNT, MIN, MAX, AVERAGE.\r\n// This script can create a lot of measures, as by default the aggregation function for columns with a numeric data type is SUM.\r\n// So, it is a good idea to check all columns for the proper aggregation type, e.g. the aggregation type of id columns \r\n// should be set to None, as it does not make any sense to aggregate id columns.\r\n// An annotation:CreatedThrough is created with a value:CreateExplicitMeasures this will help to identify the measures createed\r\n// using this script.\r\n// What is missing, the list below shows what might be coming in subsequent iterations of the script:\r\n// - the base column property hidden is not set to true\r\n// - no black list is used to prevent the creation of unwanted measures\r\n\r\n// ***************************************************************************************************************\r\n//the following variables are allowing controling the script\r\nvar overwriteExistingMeasures = 0; // 1 overwrites existing measures, 0 preserves existing measures\r\n\r\nvar measureNameTemplate = \"{0} ({1}) - {2}\"; // String.Format is used to create the measure name. \r\n//{0} will be replaced with the columnname (c.Name), {1} will be replaced with the aggregation function, and last but not least\r\n//{2} will be replaced with the tablename (t.Name). Using t.Name is necessary to create a distinction between measure names if\r\n//columns with the same name exist in different tables.\r\n//Assuming the column name inside the table \"Fact Sale\" is \"Sales revenue\" and the aggregation function is SUM \r\n//the measure name will be: \"Sales revenue (Sum) - Fact Sale\"\r\n\r\n//store aggregation function that qualify for measure creation to the hashset aggFunctions\r\nvar aggFunctions = new HashSet<AggregateFunction>{\r\n    AggregateFunction.Default, //remove this line, if you do not want to mess up your measures list by automatically created measures for all the columns that have the Default AggregateFunction assigned\r\n    AggregateFunction.Sum,\r\n    AggregateFunction.Count,\r\n    AggregateFunction.Min,\r\n    AggregateFunction.Max,\r\n    AggregateFunction.Average\r\n};\r\n\r\n//You have to be aware that by default this script will just create measures using the aggregate functions \"Sum\" or \"Count\" if\r\n//the column has the aggregate function AggregateFunction.Default assigned, this is checked further down below.\r\n//Also, if a column has the Default AggregateFunction assigned and is of the DataType\r\n//DataType.Automatic, DataType.Unknown, or DataType.Variant, no measure is created automatically, this is checked further down below.\r\n//dictDataTypeAggregateFunction = new Dictionary<DataType, string>();\r\n//see this article for all the available data types: https://docs.microsoft.com/en-us/dotnet/api/microsoft.analysisservices.tabular.datatype?view=analysisservices-dotnet\r\n//Of course you can change the aggregation function that will be used for different data types,\r\n//as long as you are using \"Sum\" and \"Count\"\r\n//Please be careful, if you change the aggregation function you might end up with multiplemeasures\r\nvar dictDataTypeAggregateFunction = new Dictionary<DataType, AggregateFunction>();\r\ndictDataTypeAggregateFunction.Add( DataType.Binary , AggregateFunction.Count ); //adding a key/value pair(s) to the dictionary using the Add() method\r\ndictDataTypeAggregateFunction.Add( DataType.Boolean , AggregateFunction.Count );\r\ndictDataTypeAggregateFunction.Add( DataType.DateTime , AggregateFunction.Count );\r\ndictDataTypeAggregateFunction.Add( DataType.Decimal , AggregateFunction.Sum );\r\ndictDataTypeAggregateFunction.Add( DataType.Double , AggregateFunction.Sum );\r\ndictDataTypeAggregateFunction.Add( DataType.Int64 , AggregateFunction.Sum );\r\ndictDataTypeAggregateFunction.Add( DataType.String , AggregateFunction.Count );\r\n\r\n// ***************************************************************************************************************\r\n//all the stuff below this line should not be altered \r\n//of course this is not valid if you have to fix my errors, make the code more efficient, \r\n//or you have a thorough understanding of what you are doing\r\n\r\n//store all the existing measures to the list listOfMeasures\r\nvar listOfMeasures = new List<string>();\r\nforeach( var m in Model.AllMeasures ) {\r\n    listOfMeasures.Add( m.Name );\r\n}\r\n\r\n//loop across all tables\r\nforeach( var t in Model.Tables ) {\r\n    \r\n    //loop across all columns of the current table t\r\n    foreach( var c in t.Columns ) {\r\n        \r\n        var currAggFunction = c.SummarizeBy; //cache the aggregation function of the current column c\r\n        var useAggFunction = AggregateFunction.Sum;\r\n        var theMeasureName = \"\"; // Name of the new Measure\r\n        var posInListOfMeasures = 0; //check if the new measure already exists <> -1\r\n        \r\n        if( aggFunctions.Contains(currAggFunction) ) //check if the current aggregation function qualifies for measure aggregation\r\n        {\r\n            //check if the current aggregation function is Default\r\n            if( currAggFunction == AggregateFunction.Default )\r\n            {\r\n                // check if the datatype of the column is considered for measure creation\r\n                if( dictDataTypeAggregateFunction.ContainsKey( c.DataType ) )\r\n                {\r\n                    \r\n                    //some kind of sanity check\r\n                    if( c.DataType == DataType.Automatic || c.DataType == DataType.Unknown || c.DataType == DataType.Variant )\r\n                    {\r\n                        Output(\"No measure will be created for columns with the data type: \" + c.DataType.ToString() + \" (\" + c.DaxObjectFullName + \")\");\r\n                        continue; //moves to the next item in the foreach loop, the next colum in the current table\r\n                    }\r\n                  \r\n                    //cache the aggregation function from the dictDataTypeAggregateFunction\r\n                    useAggFunction = dictDataTypeAggregateFunction[ c.DataType ];\r\n                    \r\n                    //some kind of sanity check\r\n                    if( useAggFunction != AggregateFunction.Count && useAggFunction != AggregateFunction.Sum ) \r\n                    {    \r\n                        Output(\"No measure will be created for the column: \" + c.DaxObjectFullName);\r\n                        continue; //moves to the next item in the foreach loop, the next colum in the current table\r\n                    }\r\n                    theMeasureName = String.Format( measureNameTemplate , c.Name , useAggFunction.ToString() , t.Name ); // Name of the new Measure\r\n                    posInListOfMeasures = listOfMeasures.IndexOf( theMeasureName ); //check if the new measure already exists <> -1\r\n                    \r\n                } else {\r\n                   \r\n                    continue; //moves to the next item in the foreach loop, the next colum in the current table\r\n                }\r\n                        \r\n            } else {\r\n                \r\n                useAggFunction = currAggFunction;    \r\n                theMeasureName = String.Format( measureNameTemplate , c.Name , useAggFunction.ToString() , t.Name ); // Name of the new Measure\r\n                posInListOfMeasures = listOfMeasures.IndexOf( theMeasureName ); //check if the new measure already exists <> -1\r\n                \r\n            }\r\n            \r\n            //sanity check\r\n            if(theMeasureName == \"\")\r\n            {\r\n                continue; //moves to the next item in the foreach loop, the next colum in the current table\r\n            }\r\n            \r\n            // create the measure\r\n            if( ( posInListOfMeasures == -1 || overwriteExistingMeasures == 1 )) \r\n            {    \r\n                if( overwriteExistingMeasures == 1 ) \r\n                {\r\n                    foreach( var m in Model.AllMeasures.Where( m => m.Name == theMeasureName ).ToList() ) \r\n                    {\r\n                        m.Delete();\r\n                    }\r\n                }\r\n                \r\n                var newMeasure = t.AddMeasure\r\n                (\r\n                    theMeasureName                                                                      // Name of the new Measure\r\n                    , \"\" + useAggFunction.ToString().ToUpper() + \"(\" + c.DaxObjectFullName + \")\"        // DAX expression\r\n                );\r\n                \r\n                newMeasure.SetAnnotation( \"CreatedThrough\" , \"CreateExplicitMeasures\" ); // flag the measures created throught this script\r\n                \r\n            }\r\n        }    \r\n    }        \r\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "Measures\\Create Measures From Columns",
      "Enabled": "true",
      "Execute": "// Creates a SUM measure for every currently selected column and hide the column.\r\nforeach(var c in Selected.Columns)\r\n{\r\n    var newMeasure = c.Table.AddMeasure(\r\n        \"Sum of \" + c.Name,                    // Name\r\n        \"SUM(\" + c.DaxObjectFullName + \")\",    // DAX expression\r\n        c.DisplayFolder                        // Display Folder\r\n    );\r\n    \r\n    // Set the format string on the new measure:\r\n    newMeasure.FormatString = \"0.00\";\r\n\r\n    // Provide some documentation:\r\n    newMeasure.Description = \"This measure is the sum of column \" + c.DaxObjectFullName;\r\n\r\n    // Hide the base column:\r\n    c.IsHidden = true;\r\n}",
      "Tooltip": "",
      "ValidContexts": "Column"
    },
    {
      "Name": "Measures\\Create Time Intelligence Measures Using Calculation Groups",
      "Enabled": "true",
      "Execute": "/*\r\n * Generate time intelligence measures based on calculation group items alredy created\r\n *\r\n * Author: Benoit Fedit, https://datakuity.com/ \r\n *\r\n * You must have created the calculation group items beforehand (see link below)\r\n * https://docs.microsoft.com/en-us/analysis-services/tabular-models/calculation-groups?view=asallproducts-allversions\r\n * To add more measure simply copy/paste the YTD script and replace YTD by your claculation item name\r\n */\r\n\r\n\r\n// For each selected measure create YTY, PY, PY YTD, YOY, YOY% measures\r\nforeach(var m in Selected.Measures) {\r\n    \r\n    // YTD\r\n    m.Table.AddMeasure(\r\n        m.Name + \" YTD\",                                       // Name\r\n        \"Calculate(\" + m.DaxObjectName + \", 'Time Intelligence'[Time Calculation]=\\\"YTD\\\")\",    \r\n        m.DisplayFolder                                        // Display Folder\r\n    );\r\n    \r\n    // PY\r\n    m.Table.AddMeasure(\r\n        m.Name + \" YTD\",                                       // Name\r\n        \"Calculate(\" + m.DaxObjectName + \", 'Time Intelligence'[Time Calculation]=\\\"PY\\\")\",    \r\n        m.DisplayFolder                                        // Display Folder\r\n    );\r\n    \r\n    // PY YTD\r\n    m.Table.AddMeasure(\r\n        m.Name + \" PY YTD\",                                       // Name\r\n        \"Calculate(\" + m.DaxObjectName + \", 'Time Intelligence'[Time Calculation]=\\\"PY YTD\\\")\",    \r\n        m.DisplayFolder                                        // Display Folder\r\n    );\r\n    \r\n    // YOY\r\n    m.Table.AddMeasure(\r\n        m.Name + \" YOY\",                                       // Name\r\n        \"Calculate(\" + m.DaxObjectName + \", 'Time Intelligence'[Time Calculation]=\\\"YOY\\\")\",    \r\n        m.DisplayFolder                                        // Display Folder\r\n    ).FormatString = \"0.0 %\";\r\n        \r\n    // YOY%\r\n    m.Table.AddMeasure(\r\n        m.Name + \" YOY%\",                                       // Name\r\n        \"Calculate(\" + m.DaxObjectName + \", 'Time Intelligence'[Time Calculation]=\\\"YOY%\\\")\",    \r\n        m.DisplayFolder                                        // Display Folder\r\n    );\r\n}",
      "Tooltip": "",
      "ValidContexts": "Measure"
    },
    {
      "Name": "Measures\\Create YTD and ITD for Selected Measures",
      "Enabled": "true",
      "Execute": "// Creates a SUM measure for every currently selected column and hide the column.\r\nforeach(var c in Selected.Measures)\r\n{\r\n    var newMeasure1 = c.Table.AddMeasure(\r\n    c.Name + \" (ITD)\",                    // Name\r\n        \"VAR lastDay = MAX ( 'PostedDate'[DateKey] )\\n\\nRETURN\\n    CALCULATE ( \\n        \" + c.Expression + \", \\n        FILTER ( ALL ( 'PostedDate'[DateKey] ), 'PostedDate'[DateKey] <= lastDay )\\n    )\",    // DAX expression\r\n        c.DisplayFolder                        // Display Folder\r\n    );\r\n    \r\n    // Set the format string on the new measure:\r\n    newMeasure1.FormatString = c.FormatString;\r\n\r\n    // Provide some documentation:\r\n    newMeasure1.Description = \"This measure is the ITD (Inception To Date) by Value Date/PostedDate of measure \" + c.DaxObjectFullName;\r\n    \r\n    \r\n    \r\n    var newMeasure2 = c.Table.AddMeasure(\r\n        c.Name + \" (YTD)\",                    // Name\r\n        \"TOTALYTD ( \" + c.Expression + \", 'PostedDate'[DateKey] )\",    // DAX expression\r\n        c.DisplayFolder                        // Display Folder\r\n    );\r\n    \r\n    // Set the format string on the new measure:\r\n    newMeasure2.FormatString = c.FormatString;\r\n\r\n    // Provide some documentation:\r\n    newMeasure2.Description = \"This measure is the YTD (Year To Date) by Value Date/PostedDate of measure \" + c.DaxObjectFullName;\r\n    \r\n    \r\n    \r\n    \r\n    var newMeasure3 = c.Table.AddMeasure(\r\n    c.Name + \" (ITD by Fiscal Date)\",                    // Name\r\n        \"VAR lastDay = MAX ( 'EffectiveDate'[DateKey] )\\n\\nRETURN\\n    CALCULATE ( \\n        \" + c.Expression + \", \\n        FILTER ( ALL ( 'EffectiveDate'[DateKey] ), 'EffectiveDate'[DateKey] <= lastDay )\\n    )\",    // DAX expression\r\n        c.DisplayFolder                        // Display Folder\r\n    );\r\n    \r\n    // Set the format string on the new measure:\r\n    newMeasure3.FormatString = c.FormatString;\r\n\r\n    // Provide some documentation:\r\n    newMeasure3.Description = \"This measure is the ITD (Inception To Date) by Value Date/EffectiveDate of measure \" + c.DaxObjectFullName;\r\n    \r\n    \r\n    \r\n    var newMeasure4 = c.Table.AddMeasure(\r\n        c.Name + \" (YTD by Fiscal Date)\",                    // Name\r\n        \"TOTALYTD ( \" + c.Expression + \", 'EffectiveDate'[DateKey] )\",    // DAX expression\r\n        c.DisplayFolder                        // Display Folder\r\n    );\r\n    \r\n    // Set the format string on the new measure:\r\n    newMeasure4.FormatString = c.FormatString;\r\n\r\n    // Provide some documentation:\r\n    newMeasure4.Description = \"This measure is the YTD (Year To Date) by Value Date/EffectiveDate of measure \" + c.DaxObjectFullName;\r\n    \r\n}",
      "Tooltip": "",
      "ValidContexts": "Measure"
    },
    {
      "Name": "Measures\\Create YTD and ITD for Selected Measures (Using Measure Name)",
      "Enabled": "true",
      "Execute": "// Creates a SUM measure for every currently selected column and hide the column.\r\nforeach(var c in Selected.Measures)\r\n{\r\n    var newMeasure1 = c.Table.AddMeasure(\r\n    c.Name + \" (ITD)\",                    // Name\r\n        \"VAR lastDay = MAX ( 'PostedDate'[DateKey] )\\n\\nRETURN\\n    CALCULATE ( \\n        \" + c.DaxObjectFullName + \", \\n        FILTER ( ALL ( 'PostedDate'[DateKey] ), 'PostedDate'[DateKey] <= lastDay )\\n    )\",    // DAX expression\r\n        c.DisplayFolder                        // Display Folder\r\n    );\r\n    \r\n    // Set the format string on the new measure:\r\n    newMeasure1.FormatString = c.FormatString;\r\n\r\n    // Provide some documentation:\r\n    newMeasure1.Description = \"This measure is the ITD (Inception To Date) by Value Date/PostedDate of measure \" + c.DaxObjectFullName;\r\n    \r\n    \r\n    \r\n    var newMeasure2 = c.Table.AddMeasure(\r\n        c.Name + \" (YTD)\",                    // Name\r\n        \"TOTALYTD ( \" + c.DaxObjectFullName + \", 'PostedDate'[DateKey] )\",    // DAX expression\r\n        c.DisplayFolder                        // Display Folder\r\n    );\r\n    \r\n    // Set the format string on the new measure:\r\n    newMeasure2.FormatString = c.FormatString;\r\n\r\n    // Provide some documentation:\r\n    newMeasure2.Description = \"This measure is the YTD (Year To Date) by Value Date/PostedDate of measure \" + c.DaxObjectFullName;\r\n    \r\n    \r\n    \r\n    \r\n    var newMeasure3 = c.Table.AddMeasure(\r\n    c.Name + \" (ITD by Fiscal Date)\",                    // Name\r\n        \"VAR lastDay = MAX ( 'EffectiveDate'[DateKey] )\\n\\nRETURN\\n    CALCULATE ( \\n        \" + c.DaxObjectFullName + \", \\n        FILTER ( ALL ( 'EffectiveDate'[DateKey] ), 'EffectiveDate'[DateKey] <= lastDay )\\n    )\",    // DAX expression\r\n        c.DisplayFolder                        // Display Folder\r\n    );\r\n    \r\n    // Set the format string on the new measure:\r\n    newMeasure3.FormatString = c.FormatString;\r\n\r\n    // Provide some documentation:\r\n    newMeasure3.Description = \"This measure is the ITD (Inception To Date) by Fiscal Date/EffectiveDate of measure \" + c.DaxObjectFullName;\r\n    \r\n    \r\n    \r\n    var newMeasure4 = c.Table.AddMeasure(\r\n        c.Name + \" (YTD by Fiscal Date)\",                    // Name\r\n        \"TOTALYTD ( \" + c.DaxObjectFullName + \", 'EffectiveDate'[DateKey] )\",    // DAX expression\r\n        c.DisplayFolder                        // Display Folder\r\n    );\r\n    \r\n    // Set the format string on the new measure:\r\n    newMeasure4.FormatString = c.FormatString;\r\n\r\n    // Provide some documentation:\r\n    newMeasure4.Description = \"This measure is the YTD (Year To Date) by Fiscal Date/EffectiveDate of measure \" + c.DaxObjectFullName;\r\n    \r\n}",
      "Tooltip": "",
      "ValidContexts": "Measure"
    },
    {
      "Name": "Measures\\Dynamic Measure Selector",
      "Enabled": "true",
      "Execute": "/*\r\n * Title: Dynamic measure selector\r\n * \r\n * Author: Daniel Otykier, twitter.com/DOtykier\r\n * \r\n * Use this script to auto-generate a disconnected measure selector table\r\n * along with a single SWITCH measure, for a selection of measures.\r\n * More info: https://tabulareditor.com/2020/08/24/Generating-a-dynamic-measure-selector.html\r\n */\r\n\r\n// (1) Name of disconnected selector table:\r\nvar selectorTableName = \"Measure Selector\";\r\n\r\n// (2) Name of column on selector table:\r\nvar selectorTableColumnName = \"Measure\";\r\n\r\n// (3) Name of dynamic switch measure:\r\nvar dynamicMeasureName = \"Dynamic Measure\";\r\n\r\n// (4) Name of dynamic switch measure's parent table:\r\nvar dynamicMeasureTableName = \"Measure Selector\";\r\n\r\n// (5) Fallback DAX expression:\r\nvar fallbackDax = \"BLANK()\";\r\n\r\n// ----- Do not modify script below this line -----\r\n\r\nif(Selected.Measures.Count == 0) {\r\n    Error(\"Select one or more measures\");\r\n    return;\r\n}\r\n\r\n// Get or create selector table:\r\nCalculatedTable selectorTable;\r\nif(!Model.Tables.Contains(selectorTableName)) Model.AddCalculatedTable(selectorTableName);\r\nselectorTable = Model.Tables[selectorTableName] as CalculatedTable;\r\n\r\n// Get or create dynamic measure:\r\nMeasure dynamicMeasure;\r\nif(!Model.Tables[dynamicMeasureTableName].Measures.Contains(dynamicMeasureName))\r\n    Model.Tables[dynamicMeasureTableName].AddMeasure(dynamicMeasureName);\r\ndynamicMeasure = Model.Tables[dynamicMeasureTableName].Measures[dynamicMeasureName];\r\n\r\n// Generate DAX for disconnected table:\r\n// SELECTCOLUMNS({\"Measure 1\", \"Measure 2\", ...}, \"Measure\", [Value])\r\nvar selectorTableDax = \"SELECTCOLUMNS(\\n    {\\n        \" +\r\n    string.Join(\",\\n        \", Selected.Measures.Select(m => \"\\\"\" + m.Name + \"\\\"\").ToArray()) +\r\n    \"\\n    },\\n    \\\"\" + selectorTableColumnName + \"\\\", [Value]\\n)\";\r\n\r\n// Generate DAX for dynamic metric:\r\n// VAR _s = SELECTEDVALUE('Metric Selection'[Value]) RETURN SWITCH(_s, ...)\r\nvar dynamicMeasureDax = \r\n    \"VAR _s =\\n    SELECTEDVALUE('\" + selectorTableName + \"'[\" + selectorTableColumnName + \"])\\n\" +\r\n    \"RETURN\\n    SWITCH(\\n        _s,\\n        \" +\r\n    string.Join(\",\\n        \", Selected.Measures.Select(m => \"\\\"\" + m.Name + \"\\\", \" + m.DaxObjectFullName).ToArray()) +\r\n    \",\\n        \" + fallbackDax + \"\\n    )\";\r\n\r\n// Assign DAX expressions:\r\nselectorTable.Expression = selectorTableDax;\r\ndynamicMeasure.Expression = dynamicMeasureDax;",
      "Tooltip": "",
      "ValidContexts": "Measure"
    },
    {
      "Name": "Other\\Auto-create relationships of Selected Tables",
      "Enabled": "true",
      "Execute": "var keySuffix = \"Key\";\r\nvar pkSuffix = \"SK\";\r\n\r\n// Loop through all currently selected tables (assumed to be fact tables):\r\nforeach(var fact in Selected.Tables)\r\n{\r\n    // Loop through all SK columns on the current table:\r\n    foreach(var factColumn in fact.Columns.Where(c => c.Name.EndsWith(keySuffix)))\r\n    {\r\n        // Find the dimension table corresponding to the current SK column:\r\n        var dim = Model.Tables.FirstOrDefault(t => factColumn.Name.EndsWith(t.Name + pkSuffix));\r\n        if(dim != null)\r\n        {\r\n            // Find the key column on the dimension table:\r\n            var dimColumn = dim.Columns.FirstOrDefault(c => factColumn.Name.EndsWith(c.Name));\r\n            if(dimColumn != null)\r\n            {\r\n                // Check whether a relationship already exists between the two columns:\r\n                if(!Model.Relationships.Any(r => r.FromColumn == factColumn && r.ToColumn == dimColumn))\r\n                {\r\n                    // If relationships already exists between the two tables, new relationships will be created as inactive:\r\n                    var makeInactive = Model.Relationships.Any(r => r.FromTable == fact && r.ToTable == dim);\r\n\r\n                    // Add the new relationship:\r\n                    var rel = Model.AddRelationship();\r\n                    rel.FromColumn = factColumn;\r\n                    rel.ToColumn = dimColumn;\r\n                    factColumn.IsHidden = true;\r\n                    if(makeInactive) rel.IsActive = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
      "Tooltip": "",
      "ValidContexts": "Table"
    },
    {
      "Name": "Other\\Import BPA Rules",
      "Enabled": "true",
      "Execute": "System.Net.WebClient w = new System.Net.WebClient(); \r\n\r\nstring path = System.Environment.GetFolderPath(System.Environment.SpecialFolder.LocalApplicationData);\r\nstring url = \"https://raw.githubusercontent.com/microsoft/Analysis-Services/master/BestPracticeRules/BPARules.json\";\r\nstring downloadLoc = path+@\"\\TabularEditor\\BPARules.json\";\r\nw.DownloadFile(url, downloadLoc);",
      "Tooltip": "",
      "ValidContexts": "Model, Table, Measure, Column"
    },
    {
      "Name": "Other\\Transform Table to Date Table",
      "Enabled": "true",
      "Execute": "var availableCustomFormatsFolder = new List<string>() {\"FiscalMMYYYY\", \"FullDate\", \"MMYYYY\", \"FullDateDesc\"};\r\nvar availableDaysFolder = new List<string>() {\"DayName\", \"DayOfMonth\", \"DayOfQuarter\", \"DayOfWeek\", \"DayOfWeekInMonth\", \"DayOfWeekInYear\", \"DayOfYear\", \"DaySuffix\", \"FiscalDayOfYear\"};\r\nvar availableFirstAndLastDaysFolder = new List<string>() {\"FirstDayOfMonth\", \"FirstDayOfQuarter\", \"FirstDayOfYear\", \"FiscalFirstDayOfMonth\", \"FiscalFirstDayOfQuarter\", \"FiscalFirstDayOfYear\", \"FiscalLastDayOfMonth\", \"FiscalLastDayOfQuarter\", \"FiscalDayOfYear\", \"FiscalLastDayOfYear\", \"LastDayOfMonth\", \"LastDayOfQuarter\", \"LastDayOfYear\"};\r\nvar availableMonthsFolder = new List<string>() {\"FiscalMonth\", \"FiscalMonthYear\", \"Month\", \"MonthName\", \"MonthOfQuarter\", \"MonthYear\"};\r\nvar availableQuarterFolder = new List<string>() {\"FiscalQuarter\", \"FiscalQuarterName\", \"Quarter\", \"QuarterName\"};\r\nvar availableWeeksFolder = new List<string>() {\"FiscalWeekOfYear\", \"WeekOfMonth\", \"WeekOfQuarter\", \"WeekOfYear\"};\r\nvar availableHolidaysFolder = new List<string>() {\"HolidayNameinUSA\", \"IsHolidayinUSA\", \"HolidayUSA\", \"IsHolidayUSA\", \"IsWeekday\"};\r\nvar availableYearsFolder = new List<string>() {\"FiscalYear\", \"FiscalYearName\", \"Year\", \"YearName\"};\r\n\r\nforeach(var column in Selected.Tables.SelectMany(t => t.Columns)) \r\n{\r\n    \r\n    var name = column.Name;\r\n    var camelCaseName = name.Replace(\" \", \"\");\r\n    \r\n    // Apply default mask for Date/Datetime Fields\r\n    if (column.DataType == DataType.DateTime && column.FormatString != \"dd/MM/yyyy\") {\r\n        column.FormatString = \"dd/MM/yyyy\";\r\n    }\r\n    \r\n    if (camelCaseName == \"DateKey\" || column.IsKey == true) {\r\n        column.DisplayFolder = \"Custom Formats\";\r\n        column.DataType = DataType.DateTime;\r\n    }\r\n    else if (availableCustomFormatsFolder.Contains(camelCaseName)) {\r\n        column.DisplayFolder = \"Custom Formats\";\r\n\r\n        if (camelCaseName == \"FullDateDesc\") {\r\n            column.SortByColumn = column.Table.Columns[\"Date Key\"];\r\n        }\r\n\r\n    }\r\n    else if (availableDaysFolder.Contains(camelCaseName)) {\r\n        \r\n        column.DisplayFolder = \"Days\";\r\n        \r\n        if (camelCaseName == \"DayName\") {\r\n            column.SortByColumn = column.Table.Columns[\"Day Of Week\"];\r\n        }\r\n        \r\n        if (camelCaseName == \"DaySuffix\") {\r\n            column.SortByColumn = column.Table.Columns[\"Day Of Month\"];\r\n        }\r\n        \r\n    }\r\n    else if (availableFirstAndLastDaysFolder.Contains(camelCaseName)) {\r\n        column.DisplayFolder = \"First and Last Days\";\r\n        column.FormatString = \"General Date\";\r\n    }\r\n    else if (availableMonthsFolder.Contains(camelCaseName)) {\r\n        \r\n        column.DisplayFolder = \"Months\";\r\n        \r\n        if (camelCaseName == \"FiscalMonthYear\") {\r\n            column.SortByColumn = column.Table.Columns[\"Fiscal MMYYYY\"];\r\n        }\r\n        \r\n        if (camelCaseName == \"MonthName\") {\r\n            column.SortByColumn = column.Table.Columns[\"Month\"];\r\n        }\r\n    \r\n        if (camelCaseName == \"MonthYear\") {\r\n            column.SortByColumn = column.Table.Columns[\"MMYYYY\"];\r\n        }\r\n        \r\n    }\r\n    else if (availableQuarterFolder.Contains(camelCaseName)) {\r\n        \r\n        column.DisplayFolder = \"Quarters\";\r\n        \r\n        if (camelCaseName == \"FiscalQuarterName\") {\r\n            column.SortByColumn = column.Table.Columns[\"Fiscal Quarter\"];\r\n        }\r\n        \r\n        if (camelCaseName == \"QuarterName\") {\r\n            column.SortByColumn = column.Table.Columns[\"Quarter\"];\r\n        }\r\n    \r\n    }\r\n    else if (availableWeeksFolder.Contains(camelCaseName)) {\r\n        column.DisplayFolder = \"Weeks\";\r\n    }\r\n    else if (availableHolidaysFolder.Contains(camelCaseName)) {\r\n        column.DisplayFolder = \"Working Days\";\r\n    }\r\n    else if (availableYearsFolder.Contains(camelCaseName)) {\r\n        \r\n        column.DisplayFolder = \"Years\";\r\n        \r\n        if (camelCaseName == \"FiscalYearName\") {\r\n            column.SortByColumn = column.Table.Columns[\"Fiscal Year\"];\r\n        }\r\n        \r\n        if (camelCaseName == \"YearName\") {\r\n            column.SortByColumn = column.Table.Columns[\"Year\"];\r\n        }\r\n    \r\n    }\r\n    \r\n    \r\n    //Apply Camel Case on Column Name\r\n    var oldName = column.Name;\r\n    var newName = new System.Text.StringBuilder();\r\n    \r\n    for(int i = 0; i < oldName.Length; i++) {\r\n        \r\n        // First letter should always be capitalized:\r\n        if(i == 0) newName.Append(Char.ToUpper(oldName[i]));\r\n\r\n        // A sequence of two uppercase letters followed by a lowercase letter should have a space inserted\r\n        // after the first letter:\r\n        else if(i + 2 < oldName.Length && char.IsLower(oldName[i + 2]) && char.IsUpper(oldName[i + 1]) && char.IsUpper(oldName[i]))\r\n        {\r\n            newName.Append(oldName[i]);\r\n            newName.Append(\" \");\r\n        }\r\n\r\n        // All other sequences of a lowercase letter followed by an uppercase letter, should have a space\r\n        // inserted after the first letter:\r\n        else if(i + 1 < oldName.Length && char.IsLower(oldName[i]) && char.IsUpper(oldName[i+1]))\r\n        {\r\n            newName.Append(oldName[i]);\r\n            newName.Append(\" \");\r\n        }\r\n        else\r\n        {\r\n            newName.Append(oldName[i]);\r\n        }\r\n    }\r\n    \r\n    column.Name = newName.ToString();\r\n    \r\n}\r\n\r\n\r\n// Create Date Hierarchy\r\nvar selectedTable = Selected.Table.Name;\r\nif (!Model.Tables[selectedTable].Hierarchies.Contains(\"Date Hierarchy\")) {\r\n    \r\n    var h = Model.Tables[selectedTable].AddHierarchy(\"Date Hierarchy\");\r\n    \r\n    h.AddLevel(\"Year\");\r\n    h.AddLevel(\"Month Name\");\r\n    h.AddLevel(\"Day Of Month\");\r\n    h.DisplayFolder = \"Custom Formats\";\r\n}\r\n",
      "Tooltip": "",
      "ValidContexts": "Table"
    },
    {
      "Name": "Other\\View Dependencies Between Tables and Measures",
      "Enabled": "true",
      "Execute": "string tsv = \"Measure\\tDependsOnTable\"; // TSV file header row\r\n\r\n// Loop through all measures:\r\nforeach(var m in Model.AllMeasures) {\r\n\r\n    // Get a list of ALL objects referenced by this measure (both directly and indirectly through other measures):\r\n    var allReferences = m.DependsOn.Deep();\r\n\r\n    // Filter the previous list of references to table references only. For column references, let's get th\r\n    // table that each column belongs to. Finally, keep only distinct tables:\r\n    var allTableReferences = allReferences.OfType<Table>()\r\n        .Concat(allReferences.OfType<Column>().Select(c => c.Table)).Distinct();\r\n\r\n    // Output TSV rows - one for each table reference:\r\n    foreach(var t in allTableReferences)\r\n        tsv += string.Format(\"\\r\\n{0}\\t{1}\", m.Name, t.Name);\r\n}\r\n    \r\ntsv.Output();   ",
      "Tooltip": "",
      "ValidContexts": "Model, Relationship"
    },
    {
      "Name": "Other\\View Model Documentation",
      "Enabled": "true",
      "Execute": "// Construct a list of all visible columns and measures:\r\nvar objects = Model.AllMeasures.Where(m => !m.IsHidden && !m.Table.IsHidden).Cast<ITabularNamedObject>()\r\n      .Concat(Model.AllColumns.Where(c => !c.IsHidden && !c.Table.IsHidden));\r\n\r\n// Get their properties in TSV format (tabulator-separated):\r\nvar tsv = ExportProperties(objects,\"Name,ObjectType,Parent,Description,FormatString,DataType,Expression\");\r\n\r\n// (Optional) Output to screen (can then be copy-pasted into Excel):\r\ntsv.Output();",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "Performance\\Apply IsAvailableInMDX changes",
      "Enabled": "true",
      "Execute": "foreach(var column in Model.Tables.SelectMany(t => t.Columns)) \r\n{\r\n    \r\n    if(column.IsHidden) {\r\n        column.IsAvailableInMDX = false;\r\n    }\r\n    else if ( ( column.DataType == DataType.Decimal || column.DataType == DataType.Double || column.DataType == DataType.Int64 ) && column.SummarizeBy != AggregateFunction.None ) {\r\n        column.IsAvailableInMDX = false;\r\n    }\r\n    else {\r\n        column.IsAvailableInMDX = true;\r\n    }\r\n    \r\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "Performance\\Change Double DataType to Decimal",
      "Enabled": "true",
      "Execute": "foreach(var column in Model.Tables.SelectMany(t => t.Columns)) {\r\n    \r\n    if(column.DataType == DataType.Double)         \r\n        column.DataType = DataType.Decimal;\r\n    \r\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "Performance\\Change Encoding Type for Decimal Columns to Value",
      "Enabled": "true",
      "Execute": "foreach(var column in Model.Tables.SelectMany(t => t.Columns)) {\r\n    \r\n    if(column.DataType == DataType.Decimal)         \r\n        column.EncodingHint = EncodingHintType.Value;\r\n    \r\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "Performance\\Change Relationship DateTime Behavior to DatePartOnly",
      "Enabled": "true",
      "Execute": "foreach(var rel in Model.Relationships) {\r\n    \r\n    rel.JoinOnDateBehavior = DateTimeRelationshipBehavior.DatePartOnly;\r\n    \r\n}",
      "Tooltip": "",
      "ValidContexts": "Model"
    },
    {
      "Name": "Formatting\\Hide Id Columns",
      "Enabled": "true",
      "Execute": "foreach(var obj in Model.Tables.SelectMany(t => t.Columns)) {\r\n    \r\n    var coluna = obj.Name;\r\n    \r\n    if (coluna.EndsWith(\"SK\") || coluna.EndsWith(\"Id\")) {\r\n        if (coluna.Length > 2) {\r\n            obj.IsHidden = true;\r\n        }\r\n    }\r\n    \r\n}\r\n",
      "Tooltip": "",
      "ValidContexts": "Model"
    }
  ]
}
